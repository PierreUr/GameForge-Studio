<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameForge Studio - Entwicklungs-Handbuch</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: sans-serif; }
        .task-entry {
            border-left: 4px solid #4a5568;
            margin-bottom: 2rem;
            padding-left: 1.5rem;
        }
        .task-entry h3 {
            font-size: 1.25rem;
            line-height: 1.75rem;
        }
        .task-entry h4 {
            font-size: 1.125rem;
            line-height: 1.75rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-300">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <header class="mb-8 border-b border-gray-700 pb-4">
            <h1 class="text-4xl font-bold text-white">GameForge Studio - Entwicklungs-Handbuch</h1>
            <p class="text-lg text-gray-400 mt-2">Ein lebendiges Dokument, das den Fortschritt und die technischen Details des Projekts festhält.</p>
        </header>

        <main>
            <section id="einfuehrung">
                <h2 class="text-2xl font-semibold text-white mb-4">Einführung</h2>
                <p>Dieses Handbuch wird automatisch mit dem Fortschritt des GameForge Studio Projekts erweitert. Jeder abgeschlossene Entwicklungsschritt (Task) wird hier mit einer technischen Beschreibung, Code-Beispielen und Testergebnissen dokumentiert.</p>
                <p>Es dient als zentrale Wissensdatenbank und technisches Logbuch für das gesamte Entwicklungsteam.</p>
            </section>

            <hr class="my-8 border-gray-700">

            <section id="tasks">
                <h2 class="text-2xl font-semibold text-white mb-6">Abgeschlossene Tasks</h2>

                <div class="task-entry">
                    <h3 class="font-semibold text-blue-400 mb-2">Task 019: Frontend UI: Aufgabenverwaltung (Erweitert)</h3>
                    <p class="mb-4">Implementierung einer neuen Benutzeroberfläche zur grundlegenden Verwaltung von Aufgaben. Die neue Ansicht wurde als "Tasks"-Tab in das Admin-Dashboard integriert.</p>
                    <h4 class="font-semibold text-gray-200 mt-4 mb-2">Implementierungsdetails:</h4>
                    <ul class="list-disc ml-6 text-gray-400">
                        <li>Eine neue React-Komponente <code>TaskManagementPanel.tsx</code> wurde erstellt, die das UI für die Aufgabenverwaltung kapselt.</li>
                        <li>Die Komponente enthält ein Formular zum Erstellen neuer Aufgaben mit Titel, Beschreibung, Status und Priorität.</li>
                        <li>Eine Tabelle zeigt alle vorhandenen Aufgaben an und bietet einen "Delete"-Button pro Aufgabe.</li>
                        <li>Die Komponente kommuniziert über den client-seitigen <code>TasksService</code> mit dem simulierten Backend, um Aufgaben abzurufen, zu erstellen und zu löschen.</li>
                        <li>Die neue Ansicht wurde als Tab in die <code>AdminDashboard.tsx</code>-Komponente integriert.</li>
                    </ul>
                    <h4 class="font-semibold text-gray-200 mt-4 mb-2">Test-Szenario & Erwartetes Ergebnis:</h4>
                    <p class="text-gray-400">
                        <strong>Test:</strong> Manuelles Erstellen und Löschen einer Aufgabe über die UI.<br>
                        <strong>Anweisung:</strong> Navigieren Sie als Admin-Benutzer zum Admin-Dashboard und wählen Sie den "Tasks"-Tab. Füllen Sie das Formular aus, um eine neue Aufgabe zu erstellen, und klicken Sie auf "Create Task". Klicken Sie anschließend auf den "Delete"-Button bei der neu erstellten Aufgabe.<br>
                        <strong>Erwartetes Ergebnis:</strong> Die neue Aufgabe erscheint nach der Erstellung in der Tabelle. Nach dem Klick auf "Delete" und Bestätigung des Dialogs wird die Aufgabe aus der Tabelle entfernt. Dies bestätigt die korrekte Funktion der UI und der angebundenen Service-Logik.
                    </p>
                </div>

                <div class="task-entry">
                    <h3 class="font-semibold text-blue-400 mb-2">Task 018: Aufgaben-CRUD API (Erweitert)</h3>
                    <p class="mb-4">Implementierung der serverseitigen Logik für die Erstellung und Aktualisierung von Aufgaben gemäß dem erweiterten Schema. Da die Anwendung eine simulierte Datenbank verwendet, wurde ein neuer Service für diese Geschäftslogik erstellt.</p>
                    <h4 class="font-semibold text-gray-200 mt-4 mb-2">Implementierungsdetails:</h4>
                    <ul class="list-disc ml-6 text-gray-400">
                        <li>Ein neuer, simulierter `TasksService` (<code>src/server/services/TasksService.ts</code>) wurde erstellt, um die CRUD-Operationen für Aufgaben zu kapseln.</li>
                        <li>Die `create`-Methode akzeptiert ein Datenobjekt für eine neue Aufgabe, validiert die Eingaben (z.B. auf vorhandene Zuweisungen/Tags) und speichert das neue Task-Objekt in der In-Memory-Datenbank.</li>
                        <li>Die `update`-Methode findet eine bestehende Aufgabe anhand ihrer ID und aktualisiert ihre Eigenschaften mit den übergebenen Daten.</li>
                        <li>Ein client-seitiger Wrapper-Service (<code>src/core/auth/TasksService.ts</code>) wurde ebenfalls erstellt, um die simulierten Backend-Aufrufe asynchron für das Frontend bereitzustellen.</li>
                    </ul>
                    <h4 class="font-semibold text-gray-200 mt-4 mb-2">Test-Szenario & Erwartetes Ergebnis:</h4>
                    <p class="text-gray-400">
                        <strong>Test:</strong> Manuelles Erstellen und Aktualisieren einer Aufgabe über die Browser-Konsole.<br>
                        <strong>Anweisung:</strong> Rufen Sie in der Entwicklerkonsole die Funktion `TasksService.create({ title: 'Test Task', assigneeIds: [1, 2], ... })` auf. Überprüfen Sie anschließend den `localStorage` (`gameforge-db-simulation` -> `tasks`), um zu sehen, ob die Aufgabe mit den korrekten Daten erstellt wurde. Rufen Sie danach `TasksService.update(taskId, { title: 'Updated Title' })` auf und überprüfen Sie erneut den `localStorage`.<br>
                        <strong>Erwartetes Ergebnis:</strong> Die Aufgabe wird korrekt erstellt und aktualisiert, einschließlich der `assigneeIds` und anderer relationaler Daten. Dies bestätigt die korrekte Funktion der Service-Logik.
                    </p>
                </div>

                <div class="task-entry">
                    <h3 class="font-semibold text-blue-400 mb-2">Task 017: DB-Schema Aufgaben (Erweitert)</h3>
                    <p class="mb-4">Erweiterung des Datenbankschemas zur Unterstützung einer detaillierten und hierarchischen Aufgabenverwaltung. Dies ist ein reiner Backend- und Schematask, der die Grundlage für zukünftige UI-Funktionen legt.</p>
                    <h4 class="font-semibold text-gray-200 mt-4 mb-2">Implementierungsdetails:</h4>
                    <ul class="list-disc ml-6 text-gray-400">
                        <li>Neue TypeScript-Interfaces <code>Task</code> und <code>Tag</code> in <code>src/server/types.ts</code> definiert, die Felder für Hierarchie (<code>parentId</code>), Status, Priorität, Zuweisungen, Tags und Abhängigkeiten enthalten.</li>
                        <li>Die In-Memory-Datenbank-Simulation in <code>src/server/services/db.ts</code> wurde um Speicher für <code>tasks</code> und <code>tags</code> erweitert.</li>
                        <li>Ein neues Dokument <code>DOC_SETUP_BACKEND_SCHEMA_TASK.md</code> wurde erstellt, das die finale Zieldatenbank-Struktur mit vollständigen TypeORM-Entity-Definitionen beschreibt.</li>
                    </ul>
                    <h4 class="font-semibold text-gray-200 mt-4 mb-2">Test-Szenario & Erwartetes Ergebnis:</h4>
                    <p class="text-gray-400">
                        <strong>Test:</strong> Code-Review und Validierung der neuen Typen und Dokumentationen.<br>
                        <strong>Anweisung:</strong> Überprüfen Sie die Datei <code>src/server/types.ts</code> auf die neuen Interfaces <code>Task</code> und <code>Tag</code>. Überprüfen Sie die Datei <code>DOC_SETUP_BACKEND_SCHEMA_TASK.md</code> auf die korrekte Definition der TypeORM-Entitäten.<br>
                        <strong>Erwartetes Ergebnis:</strong> Die Typen und Entitätsdefinitionen entsprechen den Anforderungen aus der Task-Beschreibung (hierarchische Beziehungen, Many-to-Many für Zuweisungen/Tags, JSON-Felder etc.). Die Code-Kompilierung verläuft ohne Fehler.
                    </p>
                </div>

                <div class="task-entry">
                    <h3 class="font-semibold text-blue-400 mb-2">Task 016: API für Modul-Konfiguration</h3>
                    <p class="mb-4">Implementierung eines simulierten API-Endpunkts, um die spezifische Konfiguration eines Moduls abzurufen. Dies ermöglicht es aktiven Modulen, ihre Einstellungen zentral vom Backend zu laden.</p>
                    <h4 class="font-semibold text-gray-200 mt-4 mb-2">Implementierungsdetails:</h4>
                    <ul class="list-disc ml-6 text-gray-400">
                        <li>Eine neue Methode <code>getModuleConfig</code> wurde zum simulierten <code>ModulesService</code> (Server-Seite) hinzugefügt, die die Konfiguration anhand des Modulnamens findet.</li>
                        <li>Eine entsprechende Wrapper-Methode wurde im clientseitigen <code>ModulesService</code> implementiert, um die Funktionalität im Frontend verfügbar zu machen.</li>
                        <li>Der Zugriff ist auf authentifizierte Benutzer beschränkt.</li>
                    </ul>
                    <h4 class="font-semibold text-gray-200 mt-4 mb-2">Test-Szenario & Erwartetes Ergebnis:</h4>
                    <p class="text-gray-400">
                        <strong>Test:</strong> Manuelles Abrufen der Konfiguration eines Moduls.<br>
                        <strong>Anweisung:</strong> Erstellen Sie ein Modul (z.B. über die Admin-UI) und fügen Sie manuell im LocalStorage (<code>gameforge-db-simulation</code> -> <code>modules</code>) ein <code>configSchema</code>-Objekt hinzu (z.B. <code>{"settingA": true, "value": 123}</code>). Rufen Sie dann die Funktion <code>ModulesService.getModuleConfig('modul-name')</code> in der Browser-Konsole auf.<br>
                        <strong>Erwartetes Ergebnis:</strong> Die Konsole sollte das <code>configSchema</code>-Objekt (<code>{"settingA": true, "value": 123}</code>) ausgeben. Dies bestätigt, dass die API-Schicht korrekt funktioniert.
                    </p>
                </div>
                
                <div class="task-entry">
                    <h3 class="font-semibold text-blue-400 mb-2">Task 015: Admin-UI Modulverwaltung</h3>
                    <p class="mb-4">Implementierung eines neuen Panels im Admin-Dashboard zur Verwaltung von System-Modulen. Die Ansicht ist durch rollenbasierte Zugriffskontrolle geschützt und nur für Benutzer mit der Rolle 'SUPER_ADMIN' sichtbar.</p>
                    <h4 class="font-semibold text-gray-200 mt-4 mb-2">Implementierungsdetails:</h4>
                    <ul class="list-disc ml-6 text-gray-400">
                        <li>Neue React-Komponente <code>ModuleManagementPanel.tsx</code> erstellt.</li>
                        <li>Die Komponente ruft die Modulliste über den <code>ModulesService</code> ab und stellt sie in einer Tabelle dar.</li>
                        <li>Ein Formular ermöglicht das Erstellen neuer Module.</li>
                        <li>Aktions-Buttons in jeder Tabellenzeile erlauben das Umschalten des Aktiv-Status und das Löschen von Modulen.</li>
                        <li>Die Komponente wird nur dann im Admin-Dashboard gerendert, wenn der eingeloggte Benutzer die Rolle 'SUPER_ADMIN' besitzt.</li>
                    </ul>
                    <h4 class="font-semibold text-gray-200 mt-4 mb-2">Test-Szenario & Erwartetes Ergebnis:</h4>
                    <p class="text-gray-400">
                        <strong>Test 1 (Zugriff):</strong> Einloggen mit einem 'ADMIN'-Benutzer (nicht Super-Admin).<br>
                        <strong>Erwartetes Ergebnis:</strong> Der Tab "Modules" im Admin-Dashboard ist nicht sichtbar.<br><br>
                        <strong>Test 2 (Funktionalität):</strong> Einloggen mit einem 'SUPER_ADMIN'-Benutzer.<br>
                        <strong>Anweisung:</strong> Navigieren Sie zum Admin-Dashboard und zum "Modules"-Tab. Füllen Sie das Formular aus, um ein neues Modul zu erstellen. Klicken Sie auf den "Delete"-Button eines Moduls.<br>
                        <strong>Erwartetes Ergebnis:</strong> Das neue Modul erscheint in der Liste. Nach dem Klick auf "Delete" wird das Modul aus der Liste entfernt. Die Aktionen bestätigen die korrekte Funktion der UI und der angebundenen Service-Logik.
                    </p>
                </div>
                
                <div class="task-entry">
                    <h3 class="font-semibold text-blue-400 mb-2">Task 002: Handbuch-Initialisierung</h3>
                    <p class="mb-4">Initialisierung dieses Entwicklungs-Handbuchs. Die Seite wurde mit einem grundlegenden Layout und Styling versehen, um zukünftige, automatisch generierte Task-Dokumentationen aufzunehmen.</p>
                </div>

                <div class="task-entry">
                    <h3 class="font-semibold text-blue-400 mb-2">Task 001: UI-Setup (Progress-Bar)</h3>
                    <p class="mb-4">Initialisierung der Benutzeroberfläche mit einer Fortschrittsanzeige im Header. Die Anzeige liest dynamisch Daten aus <code>/js/progress.json</code> und visualisiert den Projektfortschritt. Zusätzlich wurde ein aufklappbarer Bereich für Test-Logs implementiert.</p>
                    <h4 class="font-semibold text-gray-200 mt-4 mb-2">Implementierungsdetails:</h4>
                    <ul class="list-disc ml-6 text-gray-400">
                        <li>Neue React-Komponente <code>ProgressBarHeader.tsx</code> erstellt.</li>
                        <li>Komponente in <code>index.tsx</code> integriert.</li>
                        <li>Datenquelle <code>/js/progress.json</code> für den Fortschritt angelegt.</li>
                        <li>Periodisches Abrufen der Daten via <code>fetch</code> alle 2 Sekunden.</li>
                    </ul>
                </div>

                <!-- Neue Einträge werden hier hinzugefügt -->

            </section>
        </main>
    </div>
</body>
</html>